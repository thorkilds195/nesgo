package main

import (
	"fmt"
	"image/color"
	"math/rand"
	"nesgo/cpu"
	"time"

	"github.com/hajimehoshi/ebiten/v2"

	// "github.com/hajimehoshi/ebiten/v2/ebitenutil"

	"log"
)

var game_code = []uint8{
	0x20, 0x06, 0x06, 0x20, 0x38, 0x06, 0x20, 0x0d, 0x06, 0x20, 0x2a, 0x06, 0x60, 0xa9, 0x02, 0x85,
	0x02, 0xa9, 0x04, 0x85, 0x03, 0xa9, 0x11, 0x85, 0x10, 0xa9, 0x10, 0x85, 0x12, 0xa9, 0x0f, 0x85,
	0x14, 0xa9, 0x04, 0x85, 0x11, 0x85, 0x13, 0x85, 0x15, 0x60, 0xa5, 0xfe, 0x85, 0x00, 0xa5, 0xfe,
	0x29, 0x03, 0x18, 0x69, 0x02, 0x85, 0x01, 0x60, 0x20, 0x4d, 0x06, 0x20, 0x8d, 0x06, 0x20, 0xc3,
	0x06, 0x20, 0x19, 0x07, 0x20, 0x20, 0x07, 0x20, 0x2d, 0x07, 0x4c, 0x38, 0x06, 0xa5, 0xff, 0xc9,
	0x77, 0xf0, 0x0d, 0xc9, 0x64, 0xf0, 0x14, 0xc9, 0x73, 0xf0, 0x1b, 0xc9, 0x61, 0xf0, 0x22, 0x60,
	0xa9, 0x04, 0x24, 0x02, 0xd0, 0x26, 0xa9, 0x01, 0x85, 0x02, 0x60, 0xa9, 0x08, 0x24, 0x02, 0xd0,
	0x1b, 0xa9, 0x02, 0x85, 0x02, 0x60, 0xa9, 0x01, 0x24, 0x02, 0xd0, 0x10, 0xa9, 0x04, 0x85, 0x02,
	0x60, 0xa9, 0x02, 0x24, 0x02, 0xd0, 0x05, 0xa9, 0x08, 0x85, 0x02, 0x60, 0x60, 0x20, 0x94, 0x06,
	0x20, 0xa8, 0x06, 0x60, 0xa5, 0x00, 0xc5, 0x10, 0xd0, 0x0d, 0xa5, 0x01, 0xc5, 0x11, 0xd0, 0x07,
	0xe6, 0x03, 0xe6, 0x03, 0x20, 0x2a, 0x06, 0x60, 0xa2, 0x02, 0xb5, 0x10, 0xc5, 0x10, 0xd0, 0x06,
	0xb5, 0x11, 0xc5, 0x11, 0xf0, 0x09, 0xe8, 0xe8, 0xe4, 0x03, 0xf0, 0x06, 0x4c, 0xaa, 0x06, 0x4c,
	0x35, 0x07, 0x60, 0xa6, 0x03, 0xca, 0x8a, 0xb5, 0x10, 0x95, 0x12, 0xca, 0x10, 0xf9, 0xa5, 0x02,
	0x4a, 0xb0, 0x09, 0x4a, 0xb0, 0x19, 0x4a, 0xb0, 0x1f, 0x4a, 0xb0, 0x2f, 0xa5, 0x10, 0x38, 0xe9,
	0x20, 0x85, 0x10, 0x90, 0x01, 0x60, 0xc6, 0x11, 0xa9, 0x01, 0xc5, 0x11, 0xf0, 0x28, 0x60, 0xe6,
	0x10, 0xa9, 0x1f, 0x24, 0x10, 0xf0, 0x1f, 0x60, 0xa5, 0x10, 0x18, 0x69, 0x20, 0x85, 0x10, 0xb0,
	0x01, 0x60, 0xe6, 0x11, 0xa9, 0x06, 0xc5, 0x11, 0xf0, 0x0c, 0x60, 0xc6, 0x10, 0xa5, 0x10, 0x29,
	0x1f, 0xc9, 0x1f, 0xf0, 0x01, 0x60, 0x4c, 0x35, 0x07, 0xa0, 0x00, 0xa5, 0xfe, 0x91, 0x00, 0x60,
	0xa6, 0x03, 0xa9, 0x00, 0x81, 0x10, 0xa2, 0x00, 0xa9, 0x01, 0x81, 0x10, 0x60, 0xa2, 0x00, 0xea,
	0xea, 0xca, 0xd0, 0xfb, 0x60,
}

const (
	screenWidth  = 32
	screenHeight = 32
)

type Game struct {
	framebuffer []byte
	texture     *ebiten.Image
	cpu         *cpu.CPU
}

func color_from_byte(b uint8) color.RGBA {
	var col color.RGBA
	switch b {
	case 0:
		col = color.RGBA{0, 0, 0, 0xFF}
	case 1:
		col = color.RGBA{0xFF, 0xFF, 0xFF, 0xFF}
	default:
		col = color.RGBA{0xFF, 0xFF, 0xFF, 0xFF}

	}
	return col
}

func read_screen_state(c *cpu.CPU, g *Game) bool {
	idx := 0
	update := false
	buf := g.framebuffer
	for i := 0x0200; i < 0x0600; i++ {
		color_idx := c.MemRead(uint16(i))
		col := color_from_byte(color_idx)
		if buf[idx] != col.R || buf[idx+1] != col.G || buf[idx+2] != col.B {
			buf[idx] = col.R
			buf[idx+1] = col.G
			buf[idx+2] = col.B
			buf[idx+3] = 0xFF
			update = true
		}
		if color_idx != 0 {
			fmt.Printf("Memory[%04X] = %d\n", i, color_idx)
		}
		idx += 4
	}
	return update
}

func NewGame() *Game {
	fb := make([]byte, screenWidth*screenHeight*4) // 4 bytes per pixel (RGBA)
	img := ebiten.NewImage(screenWidth, screenHeight)
	c := cpu.InitCPU()
	c.Load(game_code)
	c.Reset()
	return &Game{framebuffer: fb, texture: img, cpu: c}
}

func (g *Game) Update() error {
	// Handle user input first
	handle_user_input(g.cpu)

	// Step one instruction of the CPU, with a callback
	alive := g.cpu.Step(func() {
		g.cpu.MemWrite(0xFE, uint8(rand.Intn(16)+1)) // Random number between 1 and 16
	})

	if !alive {
		// Program has hit BRK (0x00) or custom HLT (0x02)
		return nil
	}

	// Check if screen memory has changed
	if read_screen_state(g.cpu, g) {
		// If it has, upload framebuffer to texture
		g.texture.WritePixels(g.framebuffer)
	}

	// Slow down emulation a little
	time.Sleep(70 * time.Microsecond)

	return nil
}

func (g *Game) Draw(screen *ebiten.Image) {
	op := &ebiten.DrawImageOptions{}
	op.GeoM.Scale(10, 10) // scale 10x
	screen.DrawImage(g.texture, op)
}

func (g *Game) Layout(outsideWidth, outsideHeight int) (int, int) {
	return screenWidth, screenHeight
}

func handle_user_input(c *cpu.CPU) {
	if ebiten.IsKeyPressed(ebiten.KeyArrowUp) {
		c.MemWrite(0xFF, 0x77)
	}
	if ebiten.IsKeyPressed(ebiten.KeyArrowDown) {
		c.MemWrite(0xFF, 0x73)
	}
	if ebiten.IsKeyPressed(ebiten.KeyArrowLeft) {
		c.MemWrite(0xFF, 0x61)
	}
	if ebiten.IsKeyPressed(ebiten.KeyArrowRight) {
		c.MemWrite(0xFF, 0x64)
	}
}

func main() {
	game := NewGame()
	ebiten.SetWindowSize(screenWidth*10, screenHeight*10) // Scale window
	ebiten.SetWindowTitle("Emulator Test Window")

	if err := ebiten.RunGame(game); err != nil {
		log.Fatal(err)
	}
}
